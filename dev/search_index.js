var documenterSearchIndex = {"docs":
[{"location":"api/#API-for-MinimumWeightTwoStageSpanningTree.jl","page":"API","title":"API for MinimumWeightTwoStageSpanningTree.jl","text":"","category":"section"},{"location":"api/#Exported-functions","page":"API","title":"Exported functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [MinimumWeightTwoStageSpanningTree]\nPrivate = false","category":"page"},{"location":"api/#MinimumWeightTwoStageSpanningTree.benders_decomposition-Tuple{MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance}","page":"API","title":"MinimumWeightTwoStageSpanningTree.benders_decomposition","text":"benders_decomposition(inst::TwoStageSpanningTreeInstance;\n    MILP_solver=GLPK.Optimizer,\n    tol=0.000001,\n    silent=false,\n)\n\nComputes an optimal solution (with tolerance tol) of the two stage spanning tree problem using a Benders approach.\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.build_solve_and_encode_instance_as_maximum_weight_forest-Tuple{}","page":"API","title":"MinimumWeightTwoStageSpanningTree.build_solve_and_encode_instance_as_maximum_weight_forest","text":"build_solve_and_encode_instance_as_maximum_weight_forest(;\n    grid_size=3,\n    seed=0,\n    nb_scenarios=10,\n    first_max=10,\n    second_max=20,\n    solver=lagrangian_heuristic_solver,\n    load_and_save=true\n)\n\nBuilds a two stage spanning tree instance with a square grid graph of width grid_size, seed for the random number generator, nb_scenarios for the second stage, first_max and second_max as first and second stage maximum weight.\n\nSolves it with solver.\n\nEncodes it for a pipeline with a maximum weight forest layer.\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.column_generation-Tuple{MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance}","page":"API","title":"MinimumWeightTwoStageSpanningTree.column_generation","text":"column_generation(inst::TwoStageSpanningTreeInstance;MILP_solver=GLPK.Optimizer,tol=0.00001)\n\nSolves the dual of the linear relaxation of the two stage spanning tree MILP using a constraint generation.\n\nReturns objective_value, duals\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.cut_generation-Tuple{MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance}","page":"API","title":"MinimumWeightTwoStageSpanningTree.cut_generation","text":"cut_generation(inst::TwoStageSpanningTreeInstance;\n    MILP_solver=GLPK.Optimizer,\n    separate_constraint_function=separate_forest_polytope_constraint_vertex_set_using_min_cut_MILP_formulation!,\n    tol=0.000001,\n    silent=false,\n)\n\nSolve the TwoStageSpanningTree instance inst using a cut generation approach.\n\nseparate_constraint_function indicates which method is used to separate the constraint on subsets of vertices. Two options are available\n\nseparate_forest_polytope_constraint_vertex_set_using_min_cut_MILP_formulation!\nseparate_forest_polytope_constraint_vertex_set_using_simple_MILP_formulation!\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.evaluate_first_stage_solution-Tuple{MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance, Any}","page":"API","title":"MinimumWeightTwoStageSpanningTree.evaluate_first_stage_solution","text":"evaluate_first_stage_solution(inst::TwoStageSpanningTreeInstance, forest)\n\nReturns the value of the solution of inst with forest as first stage solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.kruskal_maximum_weight_forest-Tuple{AbstractVector, MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance}","page":"API","title":"MinimumWeightTwoStageSpanningTree.kruskal_maximum_weight_forest","text":"kruskal_maximum_weight_forest(θ::AbstractVector;inst=inst)\n\nReturn a maximum weight forest on inst.g using θ as edge weight (returns a vector of edges)\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.lagrangian_relaxation-Tuple{MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance}","page":"API","title":"MinimumWeightTwoStageSpanningTree.lagrangian_relaxation","text":"lagrangian_relaxation(inst::TwoStageSpanningTreeInstance; nb_epochs=100)\n\nRuns\n\na subgradient algorithm during nb_epochs to solve the Lagrangian relaxation of inst (with θ initialized to 0)\na lagrangian heuristic on the resulting solution\n\nReturns lb, ub, forest, θ, training_losses with\n\nlb: value of the Lagrangian relaxation\nub: value of the solution computed by the lagrangian heuristic\nforest: solution computed by the lagrangian heuristic\nθ: second stage problem value\ntraining_losses: vector with the value of the training losses along the subgradient algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.maximum_weight_forest_linear_maximizer-Tuple{AbstractVector}","page":"API","title":"MinimumWeightTwoStageSpanningTree.maximum_weight_forest_linear_maximizer","text":"maximum_weight_forest_linear_maximizer(θ::AbstractVector;inst=inst)\n\nWrapper around kruskalmaximumweightforest(edgeweights_vector::AbstractVector, inst::TwoStageSpanningTreeInstance) that returns the solution encoded as a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-types-and-functions","page":"API","title":"Private types and functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [MinimumWeightTwoStageSpanningTree]\nPublic = false","category":"page"},{"location":"api/#MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance","page":"API","title":"MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance","text":"TwoStageSpanningTreeInstance\n\nContains all the relevant information defining a two stage spanning-tree instance.\n\nFields\n\ng::SimpleGraph{Int}: the graph\nedge_index::SparseMatrixCSC{Int64, Int64}: edge_index[src(e),dst(e)] contains the index of edge e\nnb_scenarios::Int: number of scenarios\nfirst_stage_weights_matrix::SparseMatrixCSC{Float64, Int64}:\nfirst_stage_weights_vector::Vector{Float64}:\nsecond_stage_weights::Vector{SparseMatrixCSC{Float64, Int64}}:\n\n\n\n\n\n","category":"type"},{"location":"api/#MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance-Tuple{Graphs.AbstractGraph}","page":"API","title":"MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance","text":"TwoStageSpanningTreeInstance(g::AbstractGraph;nb_scenarios=1, first_max=10, second_max=20)\n\nBuild a random TwoStageSpanningTreeInstance from graph g.\n\nnb_scenarios scenarios are drawn, with first-stage weights drawn uniformly between 0 and first_max, and second-stage weights drawn uniformly between 0 an dsecond_max.\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.build_flow_graph_for_constraint_pricing!","page":"API","title":"MinimumWeightTwoStageSpanningTree.build_flow_graph_for_constraint_pricing!","text":"function build_flow_graph_for_constraint_pricing!(\n    g::MetaGraph,\n    flow_graph::MetaDiGraph,\n    base_graph_vertices_vertex_index_in_flow_graph = Dict(),\n    base_graph_edges_vertex_index_in_flow_graph = Dict()\n)\n\nConstraint separated: ∑{e in E(X)}xe <= |X| - 1 for any ∅ ⊊ X ⊊ V`\n\ng is the undirected graph on which the forest polytope is manipulated.\nflow_graph is a MetaDiGraph. It should be empty in input. It is modified by the function and contains afterwards the MetaDiGraph used to separate the forest polytope constraint on f\n\n\n\n\n\n","category":"function"},{"location":"api/#MinimumWeightTwoStageSpanningTree.build_load_or_solve-Tuple{}","page":"API","title":"MinimumWeightTwoStageSpanningTree.build_load_or_solve","text":"build_load_or_solve(;\n    graph=grid(5,5),\n    seed=0,\n    nb_scenarios=10,\n    first_max=10,\n    second_max=20,\n    solver=lagrangian_heuristic_solver,\n    load_and_save=true\n)\n\nThree solvers available\n\ncut_solver\nbenders_solver\nlagrangian_heuristic_solver\n\nReturn inst, val, sol with:\n\ninst: the instance generated\nval: value of the solution computed\nsolution_computed: solution computed\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.edge_index-Tuple{MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance, Graphs.AbstractEdge}","page":"API","title":"MinimumWeightTwoStageSpanningTree.edge_index","text":"function edge_index(inst::TwoStageSpanningTreeInstance, e::AbstractEdge)\n\nReturns inst.edge_index[src(e),dst(e)].\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.kruskal_mst_value","page":"API","title":"MinimumWeightTwoStageSpanningTree.kruskal_mst_value","text":"kruskal_mst_value(g, distmx=weights(g); minimize=true)\n\nextends kruskal_mst to return also the mst value\n\nreturns (mst weight), (mst edges)\n\n\n\n\n\n","category":"function"},{"location":"api/#MinimumWeightTwoStageSpanningTree.kruskal_on_first_scenario_instance-Tuple{MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance}","page":"API","title":"MinimumWeightTwoStageSpanningTree.kruskal_on_first_scenario_instance","text":"kruskal_on_first_scenario_instance(instance::TwoStageSpanningTreeInstance)\n\nApplies Kruskal algorithm with weight inst.firststageweights + inst.secondstageweights[1]\n\nReturn value, firststagevalue, firststagesolution\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.lagrangian_dual-Tuple{AbstractArray}","page":"API","title":"MinimumWeightTwoStageSpanningTree.lagrangian_dual","text":"lagrangian_dual(θ::AbstractArray; inst::TwoStageSpanningTreeInstance)\n\nCompute the value of the lagrangian dual function for TwoStageSpanningTreeInstance instance inst with duals θ\n\nθ[edged_index(src(e),dst(e)),s] contains the value of the Lagrangian dual corresponding to edge e for scenario s\n\nChainRulesCore.rrule automatic differentiation with respect to θ works.\n\nReturn (value of the solution computed),(edges in the solution computed)\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.lagrangian_heuristic-Tuple{AbstractArray}","page":"API","title":"MinimumWeightTwoStageSpanningTree.lagrangian_heuristic","text":"lagrangian_heuristic(θ::AbstractArray; inst::TwoStageSpanningTreeInstance)\n\nPerforms a lagrangian heuristic on TwoStageSpanningTree instance inst with duals θ.\n\nθ[edge_index(src(e),dst(e)),s] contains the value of the Lagrangian dual corresponding to edge e for scenario s.\n\nReturn (value of the solution computed),(edges in the solution computed).\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.maximum_weight_forest_layer_linear_encoder-Tuple{MinimumWeightTwoStageSpanningTree.TwoStageSpanningTreeInstance}","page":"API","title":"MinimumWeightTwoStageSpanningTree.maximum_weight_forest_layer_linear_encoder","text":"maximum_weight_forest_layer_linear_encoder(inst::TwoStageSpanningTreeInstance)\n\nReturns X::Array{Float64} with X[f,edge_index(inst,e),s] containing the value of feature number f for edge e and scenario s\n\nFeatures used: (all are homogeneous to a cost)\n\nfirst_stage_cost\nsecond_stage_cost_quantile\nbest_stage_cost_quantile\nneighbors_first_stage_cost_quantile\nneighbors_scenario_second_stage_cost_quantile\nis_in_first_stage_x_first_stage_cost\nis_in_second_stage_x_second_stage_cost_quantile\nis_first_in_best_stage_x_best_stage_cost_quantile\nis_second_in_best_stage_x_best_stage_cost_quantile\n\nFor features with quantiles, the following quantiles are used: 0:0.1:1.\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.separate_forest_polytope_constraint_vertex_set_using_min_cut_MILP_formulation!-Tuple{MetaGraphs.MetaGraph}","page":"API","title":"MinimumWeightTwoStageSpanningTree.separate_forest_polytope_constraint_vertex_set_using_min_cut_MILP_formulation!","text":"separate_forest_polytope_constraint_vertex_set_using_min_cut_MILP_formulation!(g::MetaGraph; MILP_solver=GLPK.Optimizer)\n\nUses a simple MILP to separate the constraints Constraint separated: ∑{e in E(X)} xe <= |X| - 1 for any ∅ ⊊ X ⊊ V`\n\ng is a MetaGraph, :cb_val property contains the value of x_e\n\nreturns: found, X\n\nfound : boolean indicating if a violated constraint has been found\nX : vertex set corresponding to the violated constraint\n\n\n\n\n\n","category":"method"},{"location":"api/#MinimumWeightTwoStageSpanningTree.separate_mst_Benders_cut!-Tuple{MetaGraphs.MetaGraph}","page":"API","title":"MinimumWeightTwoStageSpanningTree.separate_mst_Benders_cut!","text":"separate_mst_Benders_cut!(g::MetaGraph ; MILP_solver=GLPK.Optimizer)\n\nseparates optimality and feasibility cuts for the Benders decomposition formulation of the MST problem\n\ninput: property :x_val contains the value of the master property :weight contains the value of the second stage\n\nreturns a boolean equals to true if the cut is a feasibility cut and false if it is an optimality cut (in that case, the cut might be satisfied)\n\nThe value of the duals μ and ν are stored in properties :mu and :nu of the g\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"optimization/#Spanning-tree-polytope-and-branch-and-cut-formulation","page":"Optimization algorithms","title":"Spanning tree polytope and branch and cut formulation","text":"","category":"section"},{"location":"optimization/#Spanning-tree-polytope","page":"Optimization algorithms","title":"Spanning tree polytope","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The spanning tree polytope mathcalP","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayll\n        sum_e in E x_e = V-1 \n        sum_e in E(X) x_e leq X - 1 qquad textfor all  emptyset subsetneq X subsetneq V\n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The forest polytope is obtained when we remove the first constraint.","category":"page"},{"location":"optimization/#Naive-MILP-for-the-separation","page":"Optimization algorithms","title":"Naive MILP for the separation","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrll\n        min_yz  sum_vin Vz_v - sum_e in E y_e x_e -1 \n        mathrmst  y_e leq z_u text and  y_e leq z_v qquad  textfor all e = (uv) \n         yz in 01\n    endarray","category":"page"},{"location":"optimization/#Min-cut-MILP-for-the-separation-problem","page":"Optimization algorithms","title":"Min cut MILP for the separation problem","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The separation problem ","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    min  X - 1 - sum_e in E(X) x_e quad textsubject to quad emptyset subsetneq X subsetneq V","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"is equivalent to","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    min  X + sum_e notin E(X) x_e - V quad textsubject to quad emptyset subsetneq X subsetneq V","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Let us define the digraph mathcalD = (mathcalVmathcalA) with vertex set mathcalV = st cup V cup E and the following arcs.","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Arc a Capacity u_a\n(se) for e in E x_e\n(eu) and (ev) for e = (uv) in E infty\n(vt) for v in V 1","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The separation problem is equivalent to finding a non-empty minimum a minimum-capacity s-t cut X in mathcalD. This can be done with the following MILP.","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrll\n        min   sum_a in mathcalA u_a z_a \n        mathrmst   y_s - y_t geq 1 \n         z_a geq y_u - y_v  text for all  a= (uv) in mathcalA \n         sum_v in V y_v geq 1 \n         yz in 01 \n    endarray","category":"page"},{"location":"optimization/#Branch-and-cut-formulation-for-the-minimum-spanning-tree-problem","page":"Optimization algorithms","title":"Branch and cut formulation for the minimum spanning tree problem","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Using the spanning tree polytope, we can reformulate the minimum spanning tree problem as","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrll\n        min displaystylesum_e in Ec_e x_e \n        mathrmstdisplaystylesum_e in E x_e = V-1 \n        displaystylesum_e in E(X) x_e leq X - 1 qquad textfor all  emptyset subsetneq X subsetneq V\n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"A callback based version of the Branch-and-Cut algorithm is implemented in the function minimum_spanning_tree_MILP!. Its keyword argument separate_constraint_function enables to select the optimization algorithm used to separate constraints:","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"separate_forest_polytope_constraint_vertex_set_using_simple_MILP_formulation! uses the naive formulation for the cut separation problem\nseparate_forest_polytope_constraint_vertex_set_using_min_cut_MILP_formulation! uses the cut-based formulation.","category":"page"},{"location":"optimization/#Branch-and-cut-formulation-for-the-two-stage-minimum-spanning-tree-problem","page":"Optimization algorithms","title":"Branch and cut formulation for the two stage minimum spanning tree problem","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"In the same vein, we can propose the following formulation of the two stage spanning tree problem","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrll\n        min displaystylesum_e in Ec_e x_e + frac1Ssum_e in Esum_s in Sd_esy_es\n        mathrmstdisplaystylesum_e in E x_e + y_es = V-1  textfor all s in S \n        displaystylesum_e in E(X) x_e + y_es leq X - 1 qquad textfor all  emptyset subsetneq X subsetneq E text and  s in S \n         xy in 01\n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Again, the keyword argument separate_constraint_function enables to select the optimization algorithm used to separate constraints among the two mentioned above.","category":"page"},{"location":"optimization/#Column-generation-formulation","page":"Optimization algorithms","title":"Column generation formulation","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The cut generation previously mentioned is quite slow.  Since minimum spanning tree can be solved efficiently, it is natural to perform and Dantzig-Wolfe reformulation of the problem previously introduced.","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"It leads to the following formulation.","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrll\n        min displaystylesum_e in Ec_e x_e +  frac1Ssum_e in Esum_s in Sd_esy_es\n        mathrmst  x_e + y_es = displaystylesum_T in mathcalTcolon e in T lambda_Ts  textfor all ein E and s in S \n         displaystylesum_T in mathcalT lambda_Ts = 1  textfor all s in S \n         xyin mathbbZ_+ \n        lambda geq 0\n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The linear relaxation of this problem can be solved by column generation, and the problem itself can be solved using a Branch-and-Price.  The column generation is implemented in the function column_generation_two_stage_spanning_tree. Practically, we have coded directly the constraint generation on the dual using a callback mechanism.","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"To avoid the Branch-and-Price, we instead use a Benders decomposition of this problem, which enables to rely on the callback-mechanism of the solve, and avoid coding the branching scheme.","category":"page"},{"location":"optimization/#Benders-decomposition","page":"Optimization algorithms","title":"Benders decomposition","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Let us now perform a Benders decomposition of the column generation formulation provided above.","category":"page"},{"location":"optimization/#Dual-of-the-second-stage-problem","page":"Optimization algorithms","title":"Dual of the second stage problem","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"If we fix x, the second stage problem for scenario s becomes","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrll\n        min_ylambda displaystyle frac1Ssum_e in Ed_esy_es\n        mathrmst  y_es = displaystylesum_T in mathcalTcolon e in T lambda_Ts - x_e   textfor all ein E  \n         displaystylesum_T in mathcalT lambda_Ts = 1 \n         y geq 0\n        lambda geq 0\n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"We have dropped the integrality constraint on y since the spanning tree polytope is integral.  Let us drop the frac1S, and remove the variables y disappear to obtain the equivalent LP","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrlll\n        min_lambda displaystyle sum_T in mathcalTlambda_T d_Ts - overbracesum_sd_esx_es^textconstant\n        mathrmst  displaystylesum_T in mathcalTcolon e in T lambda_Ts geq x_e    textfor all ein E  text(dual mu_es) \n         displaystylesum_T in mathcalT lambda_Ts = 1    text(dual nu_s) \n        lambda geq 0\n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"where d_Ts = sum_e in Td_es. Taking its dual, we get","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrlll\n        max_munu displaystyle nu_s + sum_emu_esx_e - overbracesum_sd_esx_es^textconstant\n        mathrmst  d_Rs - nu_s - sum_e in T mu_es geq 0  textfor all T in mathcalT\n        mu geq 0\n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"which we can solve using a constraint generation.","category":"page"},{"location":"optimization/#Cut-generation-algorithm","page":"Optimization algorithms","title":"Cut generation algorithm","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The separation problem for the dual above is ","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    min_T in mathcalT sum_e in T d_es - mu_es","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"where we have replaced d_Ts by its value. It is a minimum spanning tree problem and can be solved using Kruskal's algorithm.","category":"page"},{"location":"optimization/#Feasibility-and-optimality-cuts","page":"Optimization algorithms","title":"Feasibility and optimality cuts","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"If the primal admits a solution, an optimal solution nu_smu_es of the dual problem provides an optimality cut","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    theta_s geq nu_s + sum_emu_esx_e - sum_sd_esx_es","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"If the primal problem is not feasible, the solver is supposes to return an unbounded ray for the dual, that is, a solution munu such that","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayll\n        nu_s + sum_emu_esx_e  0 \n        -nu_s - sum_e in T mu_es geq 0  textfor all T in mathcalT\n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Such an unbounded ray leads to a feasibility cut","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    nu + sum_emu_ex_e leq 0","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"where we intentionally drop the scenario subscript since these feasibility cuts are not scenario dependent. Practically, since solvers do not always provide extreme-rays, probably due to identification of unfeasibility at presolve, we consider the following simplex initialization of the primal","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrlll\n        min_lambdax displaystyle sum_e in Ew_e\n        mathrmst  displaystylesum_T in mathcalTcolon e in T lambda_Ts + w_e geq x_e    textfor all ein E  text(dual mu_es) \n         displaystylesum_T in mathcalT lambda_Ts = 1    text(dual nu_s) \n        lambdaw geq 0\n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"where we have added the slack variables w. Taking its dual, we get","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrlll\n        max_munu displaystyle nu_s + sum_emu_esx_e \n        mathrmst  - nu_s - sum_e in T mu_es geq 0  textfor all T in mathcalT\n         0 leq mu leq 1 \n         nu leq 1\n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"which we can solve using a similar constraint generation.","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Practically, we start with a constraint generation on the feasibility cut dual.  If we do not identify a feasibility cut, we pass the constraint generated to the optimality cut dual. Both constraint generation are implemented using a callback mechanism in function separate_mst_Benders_cut!. ","category":"page"},{"location":"optimization/#Benders-master-problem","page":"Optimization algorithms","title":"Benders master problem","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Let us denote by mathcalF and mathcalO_s the feasibility cuts and the optimality cuts for scenario s. This leads us to the Benders master problem","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    beginarrayrlll\n        min displaystylesum_e in Ec_e x_e + sum_s in S theta_s\n        mathrmst \n         sum_e in E x_e leq V - 1  textInitial constraint not mandatory \n             nu + sum_emu_ex_e leq 0  textfor all munu in mathcalF\n         theta_s geq nu_s + sum_emu_esx_e - sum_sd_esx_es   textfor all  s in S and (munu) in mathcalO_s \n         x in 01 \n    endarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Again, we implement the separation of the feasibility and optimality cuts using a callback mechanism in two_stage_spanning_tree_benders.","category":"page"},{"location":"optimization/#Lagrangian-relaxation","page":"Optimization algorithms","title":"Lagrangian relaxation","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Let us introduce one copy of x per scenario. An equivalent formulation of the problem is","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"beginarrayll\nmin  displaystyle sum_ein Ec_e x_e + sum_e in E sum_s in Sd_esy_es \nmathrmst  mathbfx_s + mathbfy_s in mathcalP quadquad textfor all s in S  \n x_es = x_e quad quad quad textfor all e in E and s in S\nendarray","category":"page"},{"location":"optimization/#Lagrangian-dual-function-and-its-gradient","page":"Optimization algorithms","title":"Lagrangian dual function and its gradient","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Let us relax the constraint x_es = x_e. We denote by theta_es the associated Lagrange multiplier.","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"The Lagrangian dual problem becomes","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"beginarrayrlrlrl\nmax_thetamathcalG(theta)= \nmin_x sum_e in E(c_e + frac1Ssum_s in S theta_es)x_e +  frac1Ssum_s in Smin_mathbfx_smathbfy_s  sum_e in Ed_esy_es - theta_esx_es\nmathrmst 0 leq mathbfx leq M \n mathrmst  mathbfx_s + mathbfy_s in mathcalP quadquad textfor all s in S  \nendarray","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"where M is a large constant.  In theory, we would take M=+infty, but taking a finite M leads to more informative gradients.","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Solving the first stage subproblem amounts to checking the sign of c_e + sum_s in S theta_es, while the optimal solution of the second stage problem can be computed using Kruskal's algorithm.","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"We have","category":"page"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"    (nabla mathcalG(theta))_es= frac1S (x_e - x_es)","category":"page"},{"location":"optimization/#Stochastic-gradient","page":"Optimization algorithms","title":"Stochastic gradient","text":"","category":"section"},{"location":"optimization/","page":"Optimization algorithms","title":"Optimization algorithms","text":"Considering the sum on the second stage scenarios as an expectation, we can get stochastic gradients. Using a stochastic gradient descent on max_thetamathcalG(theta) amounts to a block coordinate descent. However, this will become more interesting in the context of learning pipelines.","category":"page"},{"location":"problem/#Problem-statement","page":"Problem statement","title":"Problem statement","text":"","category":"section"},{"location":"problem/","page":"Problem statement","title":"Problem statement","text":"Let G = (VE) be an undirected graph, and S be a set of scenario.  For each edge e in E, we suppose to have a first stage cost c_e in mathbbR. And for each e in E and s in S, we suppose to have a second stage cost d_es.","category":"page"},{"location":"problem/","page":"Problem statement","title":"Problem statement","text":"Let mathcalP be the spanning tree polytope in mathbbR^E. The two stage spanning tree problem can be formulated as follows,","category":"page"},{"location":"problem/","page":"Problem statement","title":"Problem statement","text":"beginarrayll\nmin  displaystyle sum_ein Ec_e y_e + dfrac1Ssum_e in E sum_s in Sd_esz_es \nmathrmst  mathbfy + mathbfz_s in mathcalP quadquad textfor all s in S \nendarray","category":"page"},{"location":"problem/","page":"Problem statement","title":"Problem statement","text":"where y_e is a binary variable indicating if e is in the first stage solution, z_es is a binary variable indicating if e is in the second stage solution for scenario s, mathbfx = (y_e)_e in E, and mathbfz_s = (z_es)_e in E.","category":"page"},{"location":"paper/#Reproduce-paper-experiments","page":"Reproduce paper experiments","title":"Reproduce paper experiments","text":"","category":"section"},{"location":"paper/","page":"Reproduce paper experiments","title":"Reproduce paper experiments","text":"In order to reproduce the paper experiments, you can","category":"page"},{"location":"paper/","page":"Reproduce paper experiments","title":"Reproduce paper experiments","text":"Download the scripts folder\nInstantiate the environment\ncd scripts\n]instantiate\nthen run the inferopt.jl script","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MinimumWeightTwoStageSpanningTree","category":"page"},{"location":"#MinimumWeightTwoStageSpanningTree","page":"Home","title":"MinimumWeightTwoStageSpanningTree","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MinimumWeightTwoStageSpanningTree.","category":"page"},{"location":"inferopt/#InferOpt-tutorial","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"","category":"section"},{"location":"inferopt/","page":"InferOpt tutorial","title":"InferOpt tutorial","text":"warning: Warning\nWork in progress","category":"page"}]
}
