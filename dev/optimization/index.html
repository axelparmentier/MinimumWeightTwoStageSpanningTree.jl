<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization algorithms · MinimumWeightTwoStageSpanningTree.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://BatyLeo.github.io/MinimumWeightTwoStageSpanningTree.jl/optimization/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MinimumWeightTwoStageSpanningTree.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../problem/">Problem statement</a></li><li class="is-active"><a class="tocitem" href>Optimization algorithms</a><ul class="internal"><li><a class="tocitem" href="#Spanning-tree-polytope-and-branch-and-cut-formulation"><span>Spanning tree polytope and branch and cut formulation</span></a></li><li><a class="tocitem" href="#Column-generation-formulation"><span>Column generation formulation</span></a></li><li><a class="tocitem" href="#Benders-decomposition"><span>Benders decomposition</span></a></li><li><a class="tocitem" href="#Lagrangian-relaxation"><span>Lagrangian relaxation</span></a></li></ul></li><li><a class="tocitem" href="../inferopt/">InferOpt tutorial</a></li><li><a class="tocitem" href="../paper/">Reproduce paper experiments</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Optimization algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/BatyLeo/MinimumWeightTwoStageSpanningTree.jl/blob/main/docs/src/optimization.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Spanning-tree-polytope-and-branch-and-cut-formulation"><a class="docs-heading-anchor" href="#Spanning-tree-polytope-and-branch-and-cut-formulation">Spanning tree polytope and branch and cut formulation</a><a id="Spanning-tree-polytope-and-branch-and-cut-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Spanning-tree-polytope-and-branch-and-cut-formulation" title="Permalink"></a></h2><h3 id="Spanning-tree-polytope"><a class="docs-heading-anchor" href="#Spanning-tree-polytope">Spanning tree polytope</a><a id="Spanning-tree-polytope-1"></a><a class="docs-heading-anchor-permalink" href="#Spanning-tree-polytope" title="Permalink"></a></h3><p>The spanning tree polytope <span>$\mathcal{P}$</span></p><p class="math-container">\[    \begin{array}{ll}
        \sum_{e \in E} x_e = |V|-1 \\
        \sum_{e \in E(X)} x_e \leq |X| - 1, \qquad \text{for all } \emptyset \subsetneq X \subsetneq V
    \end{array}\]</p><p>The forest polytope is obtained when we remove the first constraint.</p><h3 id="Naive-MILP-for-the-separation"><a class="docs-heading-anchor" href="#Naive-MILP-for-the-separation">Naive MILP for the separation</a><a id="Naive-MILP-for-the-separation-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-MILP-for-the-separation" title="Permalink"></a></h3><p class="math-container">\[    \begin{array}{rll}
        \min_{y,z}\, &amp; \sum_{v\in V}z_v - \sum_{e \in E} y_e x_e -1 \\
        \mathrm{s.t.}\, &amp; y_{e} \leq z_u \text{ and } y_e \leq z_v \qquad &amp; \text{for all }e = (u,v) \\
        &amp; y,z \in \{0,1\}
    \end{array}\]</p><h3 id="Min-cut-MILP-for-the-separation-problem"><a class="docs-heading-anchor" href="#Min-cut-MILP-for-the-separation-problem">Min cut MILP for the separation problem</a><a id="Min-cut-MILP-for-the-separation-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Min-cut-MILP-for-the-separation-problem" title="Permalink"></a></h3><p>The separation problem </p><p class="math-container">\[    \min  |X| - 1 - \sum_{e \in E(X)} x_e \quad \text{subject to} \quad \emptyset \subsetneq X \subsetneq V\]</p><p>is equivalent to</p><p class="math-container">\[    \min  |X| + \sum_{e \notin E(X)} x_e - |V| \quad \text{subject to} \quad \emptyset \subsetneq X \subsetneq V.\]</p><p>Let us define the digraph <span>$\mathcal{D} = (\mathcal{V},\mathcal{A})$</span> with vertex set <span>$\mathcal{V} = \{s,t\} \cup V \cup E$</span> and the following arcs.</p><table><tr><th style="text-align: right">Arc <span>$a$</span></th><th style="text-align: right">Capacity <span>$u_a$</span></th></tr><tr><td style="text-align: right"><span>$(s,e)$</span> for <span>$e \in E$</span></td><td style="text-align: right"><span>$x_e$</span></td></tr><tr><td style="text-align: right"><span>$(e,u)$</span> and <span>$(e,v)$</span> for <span>$e = (u,v) \in E$</span></td><td style="text-align: right"><span>$\infty$</span></td></tr><tr><td style="text-align: right"><span>$(v,t)$</span> for <span>$v \in V$</span></td><td style="text-align: right"><span>$1$</span></td></tr></table><p>The separation problem is equivalent to finding a non-empty minimum a minimum-capacity <span>$s$</span>-<span>$t$</span> cut <span>$X$</span> in <span>$\mathcal{D}$</span>. This can be done with the following MILP.</p><p class="math-container">\[    \begin{array}{rll}
        \min \, &amp; \sum_{a \in \mathcal{A}} u_a z_a \\
        \mathrm{s.t.} \, &amp; y_s - y_t \geq 1 \\
        &amp; z_a \geq y_u - y_v &amp; \text{ for all } a= (u,v) \in \mathcal{A} \\
        &amp; \sum_{v \in V} y_v \geq 1 \\
        &amp; y,z \in \{0,1\} 
    \end{array}\]</p><h3 id="Branch-and-cut-formulation-for-the-minimum-spanning-tree-problem"><a class="docs-heading-anchor" href="#Branch-and-cut-formulation-for-the-minimum-spanning-tree-problem">Branch and cut formulation for the minimum spanning tree problem</a><a id="Branch-and-cut-formulation-for-the-minimum-spanning-tree-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-and-cut-formulation-for-the-minimum-spanning-tree-problem" title="Permalink"></a></h3><p>Using the spanning tree polytope, we can reformulate the minimum spanning tree problem as</p><p class="math-container">\[    \begin{array}{rll}
        \min\,&amp; \displaystyle\sum_{e \in E}c_e x_e \\
        \mathrm{s.t.}\,&amp;\displaystyle\sum_{e \in E} x_e = |V|-1 \\
        &amp;\displaystyle\sum_{e \in E(X)} x_e \leq |X| - 1, \qquad \text{for all } \emptyset \subsetneq X \subsetneq V
    \end{array}\]</p><p>A callback based version of the Branch-and-Cut algorithm is implemented in the function <code>minimum_spanning_tree_MILP!</code>. Its keyword argument <code>separate_constraint_function</code> enables to select the optimization algorithm used to separate constraints:</p><ul><li><code>separate_forest_polytope_constraint_vertex_set_using_simple_MILP_formulation!</code> uses the naive formulation for the cut separation problem</li><li><code>separate_forest_polytope_constraint_vertex_set_using_min_cut_MILP_formulation!</code> uses the cut-based formulation.</li></ul><h3 id="Branch-and-cut-formulation-for-the-two-stage-minimum-spanning-tree-problem"><a class="docs-heading-anchor" href="#Branch-and-cut-formulation-for-the-two-stage-minimum-spanning-tree-problem">Branch and cut formulation for the two stage minimum spanning tree problem</a><a id="Branch-and-cut-formulation-for-the-two-stage-minimum-spanning-tree-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-and-cut-formulation-for-the-two-stage-minimum-spanning-tree-problem" title="Permalink"></a></h3><p>In the same vein, we can propose the following formulation of the two stage spanning tree problem</p><p class="math-container">\[    \begin{array}{rll}
        \min\,&amp; \displaystyle\sum_{e \in E}c_e x_e + \frac{1}{|S|}\sum_{e \in E}\sum_{s \in S}d_{es}y_{es}\\
        \mathrm{s.t.}\,&amp;\displaystyle\sum_{e \in E} x_e + y_{es} = |V|-1 &amp; \text{for all }s \in S \\
        &amp;\displaystyle\sum_{e \in E(X)} x_e + y_{es} \leq |X| - 1, \qquad &amp;\text{for all } \emptyset \subsetneq X \subsetneq E \text{ and } s \in S \\
        &amp; x,y \in \{0,1\}
    \end{array}\]</p><p>Again, the keyword argument <code>separate_constraint_function</code> enables to select the optimization algorithm used to separate constraints among the two mentioned above.</p><h2 id="Column-generation-formulation"><a class="docs-heading-anchor" href="#Column-generation-formulation">Column generation formulation</a><a id="Column-generation-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Column-generation-formulation" title="Permalink"></a></h2><p>The cut generation previously mentioned is quite slow.  Since minimum spanning tree can be solved efficiently, it is natural to perform and Dantzig-Wolfe reformulation of the problem previously introduced.</p><p>It leads to the following formulation.</p><p class="math-container">\[    \begin{array}{rll}
        \min\,&amp; \displaystyle\sum_{e \in E}c_e x_e +  \frac{1}{|S|}\sum_{e \in E}\sum_{s \in S}d_{es}y_{es}\\
        \mathrm{s.t.} \,&amp; x_e + y_{e,s} = \displaystyle\sum_{T \in \mathcal{T}\colon e \in T} \lambda_{Ts} &amp; \text{for all $e\in E$ and $s \in S$} \\
        &amp; \displaystyle\sum_{T \in \mathcal{T}} \lambda_{Ts} = 1 &amp; \text{for all }s \in S \\
        &amp; x,y\in \mathbb{Z}_+ \\
        &amp;\lambda \geq 0
    \end{array}\]</p><p>The linear relaxation of this problem can be solved by column generation, and the problem itself can be solved using a Branch-and-Price.  The column generation is implemented in the function <code>column_generation_two_stage_spanning_tree</code>. Practically, we have coded directly the constraint generation on the dual using a callback mechanism.</p><p>To avoid the Branch-and-Price, we instead use a Benders decomposition of this problem, which enables to rely on the callback-mechanism of the solve, and avoid coding the branching scheme.</p><h2 id="Benders-decomposition"><a class="docs-heading-anchor" href="#Benders-decomposition">Benders decomposition</a><a id="Benders-decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Benders-decomposition" title="Permalink"></a></h2><p>Let us now perform a Benders decomposition of the column generation formulation provided above.</p><h3 id="Dual-of-the-second-stage-problem"><a class="docs-heading-anchor" href="#Dual-of-the-second-stage-problem">Dual of the second stage problem</a><a id="Dual-of-the-second-stage-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-of-the-second-stage-problem" title="Permalink"></a></h3><p>If we fix <span>$x$</span>, the second stage problem for scenario <span>$s$</span> becomes</p><p class="math-container">\[    \begin{array}{rll}
        \min_{y,\lambda}\,&amp; \displaystyle \frac{1}{|S|}\sum_{e \in E}d_{es}y_{es}\\
        \mathrm{s.t.} \,&amp; y_{e,s} = \displaystyle\sum_{T \in \mathcal{T}\colon e \in T} \lambda_{Ts} - x_e  &amp; \text{for all $e\in E$}  \\
        &amp; \displaystyle\sum_{T \in \mathcal{T}} \lambda_{Ts} = 1 \\
        &amp; y \geq 0\\
        &amp;\lambda \geq 0
    \end{array}\]</p><p>We have dropped the integrality constraint on <span>$y$</span> since the spanning tree polytope is integral.  Let us drop the <span>$\frac{1}{|S|}$</span>, and remove the variables <span>$y$</span> disappear to obtain the equivalent LP</p><p class="math-container">\[    \begin{array}{rlll}
        \min_\lambda\,&amp; \displaystyle \sum_{T \in \mathcal{T}}\lambda_T d_{Ts} - \overbrace{\sum_{s}d_{es}x_{es}}^{\text{constant}}\\
        \mathrm{s.t.} \,&amp; \displaystyle\sum_{T \in \mathcal{T}\colon e \in T} \lambda_{Ts} \geq x_e   &amp; \text{for all $e\in E$} &amp; \text{(dual $\mu_{es}$)} \\
        &amp; \displaystyle\sum_{T \in \mathcal{T}} \lambda_{Ts} = 1 &amp;  &amp; \text{(dual $\nu_{s}$)} \\
        &amp;\lambda \geq 0
    \end{array}\]</p><p>where <span>$d_{Ts} = \sum_{e \in T}d_{es}$</span>. Taking its dual, we get</p><p class="math-container">\[    \begin{array}{rlll}
        \max_{\mu,\nu}\,&amp; \displaystyle \nu_s + \sum_{e}\mu_{es}x_e - \overbrace{\sum_{s}d_{es}x_{es}}^{\text{constant}}\\
        \mathrm{s.t.} \,&amp; d_{Rs} - \nu_s - \sum_{e \in T} \mu_{es} \geq 0 &amp; \text{for all }T \in \mathcal{T}\\
        &amp;\mu \geq 0
    \end{array}\]</p><p>which we can solve using a constraint generation.</p><h4 id="Cut-generation-algorithm"><a class="docs-heading-anchor" href="#Cut-generation-algorithm">Cut generation algorithm</a><a id="Cut-generation-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Cut-generation-algorithm" title="Permalink"></a></h4><p>The separation problem for the dual above is </p><p class="math-container">\[    \min_{T \in \mathcal{T}} \sum_{e \in T} d_{es} - \mu_{es},\]</p><p>where we have replaced <span>$d_{Ts}$</span> by its value. It is a minimum spanning tree problem and can be solved using Kruskal&#39;s algorithm.</p><h3 id="Feasibility-and-optimality-cuts"><a class="docs-heading-anchor" href="#Feasibility-and-optimality-cuts">Feasibility and optimality cuts</a><a id="Feasibility-and-optimality-cuts-1"></a><a class="docs-heading-anchor-permalink" href="#Feasibility-and-optimality-cuts" title="Permalink"></a></h3><p>If the primal admits a solution, an optimal solution <span>$\nu_s,\mu_{es}$</span> of the dual problem provides an optimality cut</p><p class="math-container">\[    \theta_s \geq \nu_s + \sum_{e}\mu_{es}x_e - \sum_{s}d_{es}x_{es}\]</p><p>If the primal problem is not feasible, the solver is supposes to return an unbounded ray for the dual, that is, a solution <span>$\mu,\nu$</span> such that</p><p class="math-container">\[    \begin{array}{ll}
        \nu_s + \sum_{e}\mu_{es}x_e &gt; 0 \\
        -\nu_s - \sum_{e \in T} \mu_{es} \geq 0 &amp; \text{for all }T \in \mathcal{T}
    \end{array}\]</p><p>Such an unbounded ray leads to a feasibility cut</p><p class="math-container">\[    \nu + \sum_{e}\mu_{e}x_e \leq 0\]</p><p>where we intentionally drop the scenario subscript since these feasibility cuts are not scenario dependent. Practically, since solvers do not always provide extreme-rays, probably due to identification of unfeasibility at presolve, we consider the following simplex initialization of the primal</p><p class="math-container">\[    \begin{array}{rlll}
        \min_{\lambda,x}\,&amp; \displaystyle \sum_{e \in E}w_e\\
        \mathrm{s.t.} \,&amp; \displaystyle\sum_{T \in \mathcal{T}\colon e \in T} \lambda_{Ts} + w_e \geq x_e   &amp; \text{for all $e\in E$} &amp; \text{(dual $\mu_{es}$)} \\
        &amp; \displaystyle\sum_{T \in \mathcal{T}} \lambda_{Ts} = 1 &amp;  &amp; \text{(dual $\nu_{s}$)} \\
        &amp;\lambda,w \geq 0
    \end{array}\]</p><p>where we have added the slack variables <span>$w$</span>. Taking its dual, we get</p><p class="math-container">\[    \begin{array}{rlll}
        \max_{\mu,\nu}\,&amp; \displaystyle \nu_s + \sum_{e}\mu_{es}x_e \\
        \mathrm{s.t.} \,&amp; - \nu_s - \sum_{e \in T} \mu_{es} \geq 0 &amp; \text{for all }T \in \mathcal{T}\\
        &amp; 0 \leq \mu \leq 1 \\
        &amp; \nu \leq 1
    \end{array}\]</p><p>which we can solve using a similar constraint generation.</p><p>Practically, we start with a constraint generation on the feasibility cut dual.  If we do not identify a feasibility cut, we pass the constraint generated to the optimality cut dual. Both constraint generation are implemented using a callback mechanism in function <code>separate_mst_Benders_cut!</code>. </p><h3 id="Benders-master-problem"><a class="docs-heading-anchor" href="#Benders-master-problem">Benders master problem</a><a id="Benders-master-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Benders-master-problem" title="Permalink"></a></h3><p>Let us denote by <span>$\mathcal{F}$</span> and <span>$\mathcal{O}_s$</span> the feasibility cuts and the optimality cuts for scenario <span>$s$</span>. This leads us to the Benders master problem</p><p class="math-container">\[    \begin{array}{rlll}
        \min\,&amp; \displaystyle\sum_{e \in E}c_e x_e + \sum_{s \in S} \theta_s\\
        \mathrm{s.t.} \,
        &amp; \sum_{e \in E} x_e \leq |V| - 1 &amp;&amp; \text{Initial constraint, not mandatory} \\
        &amp;     \nu + \sum_{e}\mu_{e}x_e \leq 0 &amp; \text{for all $\mu,\nu \in \mathcal{F}$}\\
        &amp; \theta_s \geq \nu_s + \sum_{e}\mu_{es}x_e - \sum_{s}d_{es}x_{es} &amp;  \text{for all  $s \in S$ and $(\mu,\nu) \in \mathcal{O}_s$} \\
        &amp; x \in \{0,1\} \\
    \end{array}\]</p><p>Again, we implement the separation of the feasibility and optimality cuts using a callback mechanism in <code>two_stage_spanning_tree_benders</code>.</p><h2 id="Lagrangian-relaxation"><a class="docs-heading-anchor" href="#Lagrangian-relaxation">Lagrangian relaxation</a><a id="Lagrangian-relaxation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-relaxation" title="Permalink"></a></h2><p>Let us introduce one copy of <span>$x$</span> per scenario. An equivalent formulation of the problem is</p><p class="math-container">\[\begin{array}{ll}
\min\, &amp; \displaystyle \sum_{e\in E}c_e x_e + \sum_{e \in E} \sum_{s \in S}d_{es}y_{es} \\
\mathrm{s.t.}\, &amp; \mathbf{x}_s + \mathbf{y}_s \in \mathcal{P}, \quad\quad \text{for all $s$ in $S$}  \\
&amp; x_{es} = x_e, \quad \quad \quad \,\text{for all $e$ in $E$ and $s$ in $S$}
\end{array}\]</p><h3 id="Lagrangian-dual-function-and-its-gradient"><a class="docs-heading-anchor" href="#Lagrangian-dual-function-and-its-gradient">Lagrangian dual function and its gradient</a><a id="Lagrangian-dual-function-and-its-gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-dual-function-and-its-gradient" title="Permalink"></a></h3><p>Let us relax the constraint <span>$x_{es} = x_e$</span>. We denote by <span>$\theta_{es}$</span> the associated Lagrange multiplier.</p><p>The Lagrangian dual problem becomes</p><p class="math-container">\[\begin{array}{rlrlrl}
\max_{\theta}\mathcal{G}(\theta)= &amp;&amp;
\min_{x}&amp; \sum_{e \in E}(c_e + \frac{1}{|S|}\sum_{s \in S} \theta_{es})x_e + &amp; \frac{1}{|S|}\sum_{s \in S}\min_{\mathbf{x}_s,\mathbf{y}_s} &amp; \sum_{e \in E}d_{es}y_{es} - \theta_{es}x_{es}\\
&amp;&amp;\mathrm{s.t.}&amp; 0 \leq \mathbf{x} \leq M 
&amp; \mathrm{s.t.}\, &amp; \mathbf{x}_s + \mathbf{y}_s \in \mathcal{P}, \quad\quad \text{for all $s$ in $S$}  
\end{array}\]</p><p>where <span>$M$</span> is a large constant.  In theory, we would take <span>$M=+\infty$</span>, but taking a finite <span>$M$</span> leads to more informative gradients.</p><p>Solving the first stage subproblem amounts to checking the sign of <span>$c_e + \sum_{s \in S} \theta_{es}$</span>, while the optimal solution of the second stage problem can be computed using Kruskal&#39;s algorithm.</p><p>We have</p><p class="math-container">\[    (\nabla \mathcal{G}(\theta))_{es}= \frac{1}{|S|} (x_e - x_{es}).\]</p><h3 id="Stochastic-gradient"><a class="docs-heading-anchor" href="#Stochastic-gradient">Stochastic gradient</a><a id="Stochastic-gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-gradient" title="Permalink"></a></h3><p>Considering the sum on the second stage scenarios as an expectation, we can get stochastic gradients. Using a stochastic gradient descent on <span>$\max_{\theta}\mathcal{G}(\theta)$</span> amounts to a block coordinate descent. However, this will become more interesting in the context of learning pipelines.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problem/">« Problem statement</a><a class="docs-footer-nextpage" href="../inferopt/">InferOpt tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 5 April 2023 11:00">Wednesday 5 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
